<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AZX (AppZone eXtensions) documentation: EEPROM utilities allowing communication with EEPROM chips of 24xx256 family.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="telit_style.css" rel="stylesheet" type="text/css"/>
<link href="telit_navtree.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 100px;">
  <td id="projectlogo"><img alt="Logo" src="telit-logo.png"/></td>
  <td id="projectalign" style="padding-left: 2em;">
   <div id="projectname">AZX (AppZone eXtensions) documentation
   &#160;<span id="projectnumber">1.1.18-CxL</span>
   </div>
   <div id="projectbrief">A set of companion utilities that make AZ development easier</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__azx__eeprom.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EEPROM utilities allowing communication with EEPROM chips of 24xx256 family.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communication functions.  <a href="struct_a_z_x___e_e_p_r_o_m___t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gafc08ba3e768fc5b3ef4b383cb5869e23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gafc08ba3e768fc5b3ef4b383cb5869e23">AZX_EEPROM_24XX256T_CONTROL_CODE</a>&#160;&#160;&#160;0x50</td></tr>
<tr class="separator:gafc08ba3e768fc5b3ef4b383cb5869e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b44dd78f22ad65614a5e98c1ca373b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gad6b44dd78f22ad65614a5e98c1ca373b">AZX_EEPROM_24XX256T_MEM_SIZE</a>&#160;&#160;&#160;32768</td></tr>
<tr class="separator:gad6b44dd78f22ad65614a5e98c1ca373b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b81db212fe9e1a04f9885f513989805"><td class="memItemLeft" align="right" valign="top"><a id="ga3b81db212fe9e1a04f9885f513989805"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AZX_EEPROM_24XX256T_PAGE_SIZE</b>&#160;&#160;&#160;64</td></tr>
<tr class="separator:ga3b81db212fe9e1a04f9885f513989805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5ffe47e59efa57771f91dfc50689e66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66">AZX_EEPROM_24XX256T_SLAVE_ADDR</a>(a2__,  a1__,  a0__)&#160;&#160;&#160;(UINT16) ((<a class="el" href="group__azx__eeprom.html#gafc08ba3e768fc5b3ef4b383cb5869e23">AZX_EEPROM_24XX256T_CONTROL_CODE</a> + ((a2__ &lt;&lt; 2) + (a1__ &lt;&lt; 1) + (a0__) )) &lt;&lt; 1)</td></tr>
<tr class="memdesc:gad5ffe47e59efa57771f91dfc50689e66"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates the slave address  <a href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66">More...</a><br /></td></tr>
<tr class="separator:gad5ffe47e59efa57771f91dfc50689e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gae15185a63c805a8bcaa0969d7b5a57d5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gae15185a63c805a8bcaa0969d7b5a57d5">AZX_EEPROM_RES_E</a> { <br />
&#160;&#160;<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5a07df5299ef4b1ff8a2e170abd6fcd096">AZX_EEPROM_RES_OK</a> = 0, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5afbe5da7ae1822ffb3e7968cb98545a15">AZX_EEPROM_RES_CANNOT_INIT</a>, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5afd12b69a2dd7e0315de970ae1358d19c">AZX_EEPROM_RES_INVALID_HANDLE</a>, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5a16b446e14545fdf58ff6b63c2625f466">AZX_EEPROM_RES_OVERFLOW</a>, 
<br />
&#160;&#160;<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5a55902786b78fd01c45d411c7a1244635">AZX_EEPROM_RES_WRITE_ERR</a>, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5a1be95abb65e1f95ea57ede467a191ac9">AZX_EEPROM_RES_READ_ERR</a>, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5a1ca954ba5b2e26ece3bd777e2acc8162">AZX_EEPROM_RES_CANNOT_ALLOCATE</a>, 
<a class="el" href="group__azx__eeprom.html#ggae15185a63c805a8bcaa0969d7b5a57d5af0a3bbbc511c1e748e2718abdc094453">AZX_EEPROM_RES_MAX</a>
<br />
 }</td></tr>
<tr class="memdesc:gae15185a63c805a8bcaa0969d7b5a57d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">return codes  <a href="group__azx__eeprom.html#gae15185a63c805a8bcaa0969d7b5a57d5">More...</a><br /></td></tr>
<tr class="separator:gae15185a63c805a8bcaa0969d7b5a57d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5eedf6970a776b71a9d46dc064d19dfe"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga5eedf6970a776b71a9d46dc064d19dfe">azx_eeprom_init</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, EEPROM_I2C_T *pI2CHandle, UINT8 devAddr, UINT16 memSize, UINT16 pageSize)</td></tr>
<tr class="memdesc:ga5eedf6970a776b71a9d46dc064d19dfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the EEPROM handle.  <a href="group__azx__eeprom.html#ga5eedf6970a776b71a9d46dc064d19dfe">More...</a><br /></td></tr>
<tr class="separator:ga5eedf6970a776b71a9d46dc064d19dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba53c6b828ccef4388ac9978ca7510fc"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gaba53c6b828ccef4388ac9978ca7510fc">azx_eeprom_deinit</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom)</td></tr>
<tr class="memdesc:gaba53c6b828ccef4388ac9978ca7510fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the EEPROM handle.  <a href="group__azx__eeprom.html#gaba53c6b828ccef4388ac9978ca7510fc">More...</a><br /></td></tr>
<tr class="separator:gaba53c6b828ccef4388ac9978ca7510fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924b6a9d7468d744515fd266618acb6d"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga924b6a9d7468d744515fd266618acb6d">azx_eeprom_eraseAll</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom)</td></tr>
<tr class="memdesc:ga924b6a9d7468d744515fd266618acb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the EEPROM.  <a href="group__azx__eeprom.html#ga924b6a9d7468d744515fd266618acb6d">More...</a><br /></td></tr>
<tr class="separator:ga924b6a9d7468d744515fd266618acb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02a69d94770ca3968c3847ba7754c77e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga02a69d94770ca3968c3847ba7754c77e">azx_eeprom_writePages</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT16 mem_address, UINT8 *pData, UINT16 size)</td></tr>
<tr class="memdesc:ga02a69d94770ca3968c3847ba7754c77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data in the EEPROM page by page.  <a href="group__azx__eeprom.html#ga02a69d94770ca3968c3847ba7754c77e">More...</a><br /></td></tr>
<tr class="separator:ga02a69d94770ca3968c3847ba7754c77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d6ab17b288d7c0e404c0d07f65b30e"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga89d6ab17b288d7c0e404c0d07f65b30e">azx_eeprom_writeByte</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT16 mem_address, UINT8 data)</td></tr>
<tr class="memdesc:ga89d6ab17b288d7c0e404c0d07f65b30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one byte of data in the EEPROM.  <a href="group__azx__eeprom.html#ga89d6ab17b288d7c0e404c0d07f65b30e">More...</a><br /></td></tr>
<tr class="separator:ga89d6ab17b288d7c0e404c0d07f65b30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce8e7227dc5523d3d36745ebb09a8f6"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga5ce8e7227dc5523d3d36745ebb09a8f6">azx_eeprom_readPages</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT16 mem_address, UINT8 *pData, UINT16 size)</td></tr>
<tr class="memdesc:ga5ce8e7227dc5523d3d36745ebb09a8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data in the EEPROM page by page.  <a href="group__azx__eeprom.html#ga5ce8e7227dc5523d3d36745ebb09a8f6">More...</a><br /></td></tr>
<tr class="separator:ga5ce8e7227dc5523d3d36745ebb09a8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f20166c535bbbdf45e3fee1dfdc1588"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#ga7f20166c535bbbdf45e3fee1dfdc1588">azx_eeprom_readSequentially</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT16 mem_address, UINT8 *pData, UINT16 size)</td></tr>
<tr class="memdesc:ga7f20166c535bbbdf45e3fee1dfdc1588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data in the EEPROM sequentially.  <a href="group__azx__eeprom.html#ga7f20166c535bbbdf45e3fee1dfdc1588">More...</a><br /></td></tr>
<tr class="separator:ga7f20166c535bbbdf45e3fee1dfdc1588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8db2ab9e36ce597bbafccb5483f4b67"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gac8db2ab9e36ce597bbafccb5483f4b67">azx_eeprom_readByte</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT16 mem_address, UINT8 *pData)</td></tr>
<tr class="memdesc:gac8db2ab9e36ce597bbafccb5483f4b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte of data from the EEPROM.  <a href="group__azx__eeprom.html#gac8db2ab9e36ce597bbafccb5483f4b67">More...</a><br /></td></tr>
<tr class="separator:gac8db2ab9e36ce597bbafccb5483f4b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5006d130c15ada37d84a98103202a7b"><td class="memItemLeft" align="right" valign="top">INT32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__azx__eeprom.html#gac5006d130c15ada37d84a98103202a7b">azx_eeprom_readByteFromCurrentAddress</a> (<a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *pEeprom, UINT8 *pData)</td></tr>
<tr class="memdesc:gac5006d130c15ada37d84a98103202a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte of data from the EEPROM.  <a href="group__azx__eeprom.html#gac5006d130c15ada37d84a98103202a7b">More...</a><br /></td></tr>
<tr class="separator:gac5006d130c15ada37d84a98103202a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gafc08ba3e768fc5b3ef4b383cb5869e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc08ba3e768fc5b3ef4b383cb5869e23">&#9670;&nbsp;</a></span>AZX_EEPROM_24XX256T_CONTROL_CODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AZX_EEPROM_24XX256T_CONTROL_CODE&#160;&#160;&#160;0x50</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>&lt; EEPROM control code (1010 by default) 24XX256 EEPROM total size in bytes </p>

</div>
</div>
<a id="gad6b44dd78f22ad65614a5e98c1ca373b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b44dd78f22ad65614a5e98c1ca373b">&#9670;&nbsp;</a></span>AZX_EEPROM_24XX256T_MEM_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AZX_EEPROM_24XX256T_MEM_SIZE&#160;&#160;&#160;32768</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>24XX256 EEPROM page size in bytes </p>

</div>
</div>
<a id="gad5ffe47e59efa57771f91dfc50689e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5ffe47e59efa57771f91dfc50689e66">&#9670;&nbsp;</a></span>AZX_EEPROM_24XX256T_SLAVE_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AZX_EEPROM_24XX256T_SLAVE_ADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a2__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a1__, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a0__&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(UINT16) ((<a class="el" href="group__azx__eeprom.html#gafc08ba3e768fc5b3ef4b383cb5869e23">AZX_EEPROM_24XX256T_CONTROL_CODE</a> + ((a2__ &lt;&lt; 2) + (a1__ &lt;&lt; 1) + (a0__) )) &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates the slave address </p>
<p>Given the three chip select bits, create the final slave address for the eeprom chip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a2__</td><td>most significant chip select bit (pin 3 on EEPROM Chip) </td></tr>
    <tr><td class="paramname">a1__</td><td>middle chip select bit (pin 2 on EEPROM Chip) </td></tr>
    <tr><td class="paramname">a0__</td><td>least significant chip select bit (pin 1 on EEPROM Chip)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the slave address </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae15185a63c805a8bcaa0969d7b5a57d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae15185a63c805a8bcaa0969d7b5a57d5">&#9670;&nbsp;</a></span>AZX_EEPROM_RES_E</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__azx__eeprom.html#gae15185a63c805a8bcaa0969d7b5a57d5">AZX_EEPROM_RES_E</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return codes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5a07df5299ef4b1ff8a2e170abd6fcd096"></a>AZX_EEPROM_RES_OK&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_OK. </p>
<p>Success </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5afbe5da7ae1822ffb3e7968cb98545a15"></a>AZX_EEPROM_RES_CANNOT_INIT&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_CANNOT_INIT. </p>
<p>Cannot initialize the eeprom handle for internal errors </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5afd12b69a2dd7e0315de970ae1358d19c"></a>AZX_EEPROM_RES_INVALID_HANDLE&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_INVALID_HANDLE. </p>
<p>Invalid handle passed to function </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5a16b446e14545fdf58ff6b63c2625f466"></a>AZX_EEPROM_RES_OVERFLOW&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_OVERFLOW. </p>
<p>Read or Write operation overflows EEPROM size </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5a55902786b78fd01c45d411c7a1244635"></a>AZX_EEPROM_RES_WRITE_ERR&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_WRITE_ERR. </p>
<p>Error in write operation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5a1be95abb65e1f95ea57ede467a191ac9"></a>AZX_EEPROM_RES_READ_ERR&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_READ_ERR. </p>
<p>Error in read operation </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5a1ca954ba5b2e26ece3bd777e2acc8162"></a>AZX_EEPROM_RES_CANNOT_ALLOCATE&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_CANNOT_ALLOCATE. </p>
<p>Cannot allocate dynamic buffer required internally </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae15185a63c805a8bcaa0969d7b5a57d5af0a3bbbc511c1e748e2718abdc094453"></a>AZX_EEPROM_RES_MAX&#160;</td><td class="fielddoc"><p>AZX_EEPROM_RES_MAX. </p>
<p>End of range, do not use </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaba53c6b828ccef4388ac9978ca7510fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba53c6b828ccef4388ac9978ca7510fc">&#9670;&nbsp;</a></span>azx_eeprom_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the EEPROM handle. </p>
<p>This function de-initializes the EEPROM handle and closes the I2C channel linked to the provided handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the structure that will be de-initialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_init(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga924b6a9d7468d744515fd266618acb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga924b6a9d7468d744515fd266618acb6d">&#9670;&nbsp;</a></span>azx_eeprom_eraseAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_eraseAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the EEPROM. </p>
<p>This function erases all the EEPROM memory, by writing 0xFF in every byte.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the structure that will be erased</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_eraseAll(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga5eedf6970a776b71a9d46dc064d19dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5eedf6970a776b71a9d46dc064d19dfe">&#9670;&nbsp;</a></span>azx_eeprom_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EEPROM_I2C_T *&#160;</td>
          <td class="paramname"><em>pI2CHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>devAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>memSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>pageSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the EEPROM handle. </p>
<p>This function initializes the EEPROM handle with the provided I2C structure, address and sizes. Opens the I2C channel for the required address. Call it before any <code>azx_eeprom_*</code> is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the structure that will be initialized </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pI2CHandle</td><td>Pointer to the structure containing the I2C configuration (SDA, SCL pins) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">devAddr</td><td>EEPROM slave address (refer to AZX_EEPROM_24XX256T_SLAVE_ADDR ) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">memSize</td><td>the full EEPROM memory size in bytes to be set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pageSize</td><td>the EEPROM page size in bytes to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="gac8db2ab9e36ce597bbafccb5483f4b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8db2ab9e36ce597bbafccb5483f4b67">&#9670;&nbsp;</a></span>azx_eeprom_readByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_readByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>mem_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one byte of data from the EEPROM. </p>
<p>This function will read a single byte from the EEPROM, starting from the given address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_address</td><td>Starting memory address as an unsigned 16bit integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>pointer to the allocated variable to store the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<pre class="fragment">UINT8 data;

i2c_h.scl_pin = 2;
i2c_h.sda_pin = 3;
res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0),
                    AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE);
if(AZX_EEPROM_RES_OK != res)
{
  return -1;
}

res = azx_eeprom_readByte(&amp;eepromH, 0x00, &amp;data);
if(AZX_EEPROM_RES_OK != res)
{
</pre><p> handle error } else { manage retrieved data }</p>
<pre class="fragment">res = azx_eeprom_deinit(&amp;eepromH);
if(AZX_EEPROM_RES_OK != res)
{
  return -1;
}
</pre> 
</div>
</div>
<a id="gac5006d130c15ada37d84a98103202a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5006d130c15ada37d84a98103202a7b">&#9670;&nbsp;</a></span>azx_eeprom_readByteFromCurrentAddress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_readByteFromCurrentAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>pData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one byte of data from the EEPROM. </p>
<p>This function will read a single byte from the EEPROM, starting from current address.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>pointer to the allocated variable to store the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<pre class="fragment">UINT8 data;

i2c_h.scl_pin = 2;
i2c_h.sda_pin = 3;
res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0),
                    AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE);
if(AZX_EEPROM_RES_OK != res)
{
  return -1;
}

res = azx_eeprom_readByte(&amp;eepromH, 0x00, &amp;data);
if(AZX_EEPROM_RES_OK != res)
{
</pre><p> handle error } else { manage retrieved data }</p>
<p>res = azx_eeprom_readByteFromCurrentAddress(&amp;eepromH, &amp;data); if(AZX_EEPROM_RES_OK != res) { handle error } else { manage retrieved data }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga5ce8e7227dc5523d3d36745ebb09a8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce8e7227dc5523d3d36745ebb09a8f6">&#9670;&nbsp;</a></span>azx_eeprom_readPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_readPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>mem_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data in the EEPROM page by page. </p>
<p>This function will read data from the EEPROM, starting from the given address. Data will be read from the memory chip with multiple "write start address + read page" operations, using the memory page size. The function will wait 1 system tick between each page read operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_address</td><td>Starting memory address as an unsigned 16bit integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>pointer to the buffer to be filled with data from the flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the data to be read, in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>#include &lt;stdio.h&gt; INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0; UINT16 randomAddr = 0x0213; char data[128];</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_readPages(&amp;eepromH, randomAddr, (UINT8*) data, sizeof(data)); if(AZX_EEPROM_RES_OK != res) { handle error } else { manage retrieved data }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga7f20166c535bbbdf45e3fee1dfdc1588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f20166c535bbbdf45e3fee1dfdc1588">&#9670;&nbsp;</a></span>azx_eeprom_readSequentially()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_readSequentially </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>mem_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data in the EEPROM sequentially. </p>
<p>This function will read data from the EEPROM, starting from the given address. Data will be read from the memory chip with multiple "read page" operations, using the memory page size, but with a single "write address" operation at the very beginning. The function will wait 1 system tick between each page read operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_address</td><td>Starting memory address as an unsigned 16bit integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>pointer to the buffer to be filled with data from the flash </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the data to be read, in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>#include &lt;stdio.h&gt; INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<p>char data[128];</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_readSequentially(&amp;eepromH, 0x00, (UINT8*) data, sizeof(data)); if(AZX_EEPROM_RES_OK != res) { handle error } else { manage retrieved data }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga89d6ab17b288d7c0e404c0d07f65b30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89d6ab17b288d7c0e404c0d07f65b30e">&#9670;&nbsp;</a></span>azx_eeprom_writeByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_writeByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>mem_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes one byte of data in the EEPROM. </p>
<p>This function will write input byte into the EEPROM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_address</td><td>Starting memory address as an unsigned 16bit integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>value to be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0;</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_writeByte(&amp;eepromH, 0x00, 'A'); if(AZX_EEPROM_RES_OK != res) { handle error }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
<a id="ga02a69d94770ca3968c3847ba7754c77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02a69d94770ca3968c3847ba7754c77e">&#9670;&nbsp;</a></span>azx_eeprom_writePages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INT32 azx_eeprom_writePages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html">AZX_EEPROM_T</a> *&#160;</td>
          <td class="paramname"><em>pEeprom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>mem_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT8 *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UINT16&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data in the EEPROM page by page. </p>
<p>This function will write input data into the EEPROM. Data will be sent to the memory chip with multiple write operations, each the size of the memory page size. The function will wait 1 system tick between each page write operation</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pEeprom</td><td>Pointer to the EEPROM structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mem_address</td><td>Starting memory address as an unsigned 16bit integer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pData</td><td>pointer to the data to be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the data to be stored, in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>AZX_EEPROM_RES_E value</dd></dl>
<p><b>Sample usage</b></p>
<p>#include &lt;string.h&gt;</p>
<p>INT32 res; <a class="el" href="struct_a_z_x___e_e_p_r_o_m___t.html" title="EEPROM handle structure This structure holds the parameters of the EEPROM handle, used by all communi...">AZX_EEPROM_T</a> eepromH = {0}; EEPROM_I2C_T i2c_h = {0}; UINT8 a2 = 0, a1 = 0, a0 = 0; UINT16 randomAddr = 0x0213; char data[] ="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789............................abcdefghijklmnopqrstuvwxyz0123456789............................"</p>
<p>i2c_h.scl_pin = 2; i2c_h.sda_pin = 3; res = azx_eeprom_init(&amp;eepromH, &amp;i2c_h, <a class="el" href="group__azx__eeprom.html#gad5ffe47e59efa57771f91dfc50689e66" title="creates the slave address">AZX_EEPROM_24XX256T_SLAVE_ADDR(a2, a1, a0)</a>, AZX_EEPROM_24XX256T_MEM_SIZE, AZX_EEPROM_24XX256T_PAGE_SIZE); if(AZX_EEPROM_RES_OK != res) { return -1; }</p>
<p>res = azx_eeprom_writePages(&amp;eepromH, randomAddr, (UINT8*) data, (UINT16) strlen(data)); if(AZX_EEPROM_RES_OK != res) { handle error }</p>
<p>res = azx_eeprom_deinit(&amp;eepromH); if(AZX_EEPROM_RES_OK != res) { return -1; } </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
    <li class="footer">
      © Telit 2019 All rights reserved.
      <a href="https://telit.com/copyright-policy/">Copyright Policy</a> |
      <a href="https://www.telit.com/editorial-policy-and-process/">Editorial Policy</a> |
      <a href="https://telit.com/eu-privacy-policy/">EU Privacy Policy</a> |
      <a href="https://telit.com/privacy-policy/">Global Privacy Policy</a> |
      <a href="https://www.telit.com/modern-slavery-statement/">Modern Slavery Statement</a> |
      <a href="https://telit.com/terms-of-use/">Terms of Use</a> </li>
  </ul>
</div>
</body>
</html>
